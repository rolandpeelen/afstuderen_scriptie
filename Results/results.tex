%----------------------------------------------------------------------------------------
%   Results
%----------------------------------------------------------------------------------------
    
    
\chapter{Results}

%----------------------------------------------------------------------------------------
%   Development
%----------------------------------------------------------------------------------------
\section{Development}
Developing a product configurator is by any measure no easy feat. Building it with realtime 3d technology may be even harder. The following three questions should be answered in this thesis.

\subsection {Is it possible to eliminate all issues (time and automation) with regards to rendering?}
WebGL renders the loaded models in realtime using software specified shaders. As seen in the analysis of the workflows in section \ref{subsub:differencesInWorkflow}, not only the rendering section disappeared in the workflow, but also the post production, compression and image planning. This meant the ability to eliminate all issues was there. There are some other points to consider though, which shall be discussed in detail in section \ref{discuss:developmentElimination}.

\subsection{What are the cost differences for development?}
\subsubsection{Creation}
A breakdown of the time estimates can be found in attachment \ref{attachment:creationTime}. While massive savings are made in the graphics / 3d department, the software department will need to spend more time working on the application. Doing everything internally at an hourly rate of €85, the total difference for the example application is €1260.83, a saving of 8.6\%. The interesting thing to note is the following: The more 3d work needs to be done, the more savings are made. In the example application there is not a whole lot of 3d modeling being done, so savings are relatively small. The software part will not be much bigger in another configurator with loads more 3d work, so the more complex the 3d part, the bigger the savings.

\subsubsection{Maintenance}
The average upgrade cycle for the CMS used in the SlimFitted configurator was 46 days (see \ref{attachment:magentoUpgradeCycle} - \cite{magentoReleaseHistory}). The average upgrade cycle for Angular was 31 days (see \ref{attachment:angularUpgradeCycle} - \cite{angularReleaseHistory}). This means slightly different things though. In the CMS version, this would mean that a technically inclined person (either from Peppr, or at the client) has to push an 'upgrade' button in the CMS. With non-breaking changes (i.e. changes in the subversions so the last X in X.X.X), this will not cause any issues. With breaking changes, they might pose an issue where a developer may have to enter and fix some things.\newline
For the custom version, this means a different thing. While one could opt to only implement full version (i.e. X.X), this is generally considered to be a bad idea. Keeping software up-to-date is better. As such, a developer would have to look at the code ever month, upgrade the version, rebuild the application, test for bugs and bring it to production. Though the updates happen every month, the critical changes and breaking changes (whereby the application changes to such an extend that it may not work anymore) happening once very year or so (\ref{attachment:angularMajor}). This means every month a developer has to spend about an hour or two updating the application, and every year a bit more (4 to 8 hours).


\subsubsection{Components \& Colours}

\subsection {What are the differences in Workflows}
\label{subsub:differencesInWorkflow}
Breaking down the old workflow into different sections gave the following:
\begin{enumerate}
	\item {\textit{Graphics}}
	\item {Image Planning}
	\item {Modeling}
	\item {Lighting / Shading}
	\item {Rendering}
	\item {Post-Production}
	\item {Compression}
	\item {\textit{Software}}
	\item {Functional Requirements}
	\item {Technical Requirements}
	\item {UX Development}
	\item {Back-End Development}
	\item {Front-End Development}
\end{enumerate}

While the new workflow gave us the following:
\begin{enumerate}
	\item {\textit{Graphics}}
	\item {Modeling}
	\item {\textit{Software}}
	\item {Functional Requirements}
	\item {Technical Requirements}
	\item {UX Development}
	\item {Back-End Development}
	\item {Front-End Development}
	\item {Lighting / Shading}
\end{enumerate}

The main differences looking at the surface are the Image Planning, Rendering, Post-Production and Compression. The software part remained quite similar, but the lighting / shading was added to the end of the software workflow in the WebGL variant. At first glance this seems a massive optimisation. But in the new workflow, there were some things that needed to be taken care of in a different way to counter those differences in workflow. Starting with the requirements and subsequently, the front-end and development. To show 3d models in browser, lots of extra time had to be spent developing a way to combine an implementation of ThreeJS and AngularJS (as seen in attachment \ref{attachment:creationTime}). The estimates not only show an increase in the time spent creating the front-end itself, but to create a fully fledged configurator with an administrative screen, the design as well as the implementation of such an application will cost more in terms of time.\newline
As for the lighting / shading, the new workflow is different in that it is all done in software. This means that the shaders have to be programmatically implemented. While this may seem to cost more time, it actually does not. The shading and lighting can be viewed in realtime and as the possibilities within WebGL are not as great as they are in most 3d rendering packages, creating shaders is actually a lot quicker.

%----------------------------------------------------------------------------------------
%   User Experience
%----------------------------------------------------------------------------------------
\section{User Experience}
Apart from the development cycle, the user experience is a huge part of whether using these types of configurators is viable or not. Even if the development is way cheaper, if users cannot use the application, problems will arise and the old method may prove to be a better option.

\subsection {Is the technology new small enough?}
\subsection {Is the technology new quick enough?}
\subsection {Is the technology compatible with the users browsing preferences?}


%----------------------------------------------------------------------------------------
%  Introduction
%----------------------------------------------------------------------------------------
\chapter{Methodology}
\section{Introduction}
Developing a product configurator is by any means no easy feat. Building it using 3d technology may be even harder. When doing a small documentary analysis to get and set a proper theoretical framework, it became abundantly clear that there is a lot of research done into the computer science behind the proposed technology (\cite{openGLsite}, \cite{microservices}, \cite{heteregoneousComputingTechniques}). Next to that, loads of research has been done into the User Experience side of (web)applications (\cite{nielsonNormanReports}). Unfortunately, the main question that needs to be answered is quite specific and at this intersection of UX and Computer Science, there is little to no prior research. This means that some of the questions outlined below will need to be answered in an experimental way. There are a couple that can only be answered using this experimental type of setting. However, there are also some questions that could be answered using interviews or a documentary analysis. But with the need of actually building a prototype, going that way would be harder than to device an experiment using the prototype.
Basically, all questions that have to do with the development cycle, can be answered using this experimental type of research. Questions regarding the UX mostly will follow a combination of multiple methods (as we need to define certain standards). The start of this section will be a deep dive into the methodology behind building the prototype, followed by the ways of researching the development and user experience research objectives.

%----------------------------------------------------------------------------------------
%   Experimental Prototype
%----------------------------------------------------------------------------------------
\section{Prototype Preparation}
\subsection{Introduction}
To keep the prototype as simple as possible, an analysis of the requirements will be made. After which a development stack shall be chosen and the development will be started. As a rough example, the example used in the theoretical framework shall be used. Most of the workflow in the build of this prototype shall be inherited from Pepprs current Software Workflow.

\say{
A chair manufacturer wants a product configurator for one of their most popular chairs. It has 25 different colour options and has 4 different subframes. Two of the subframes are steel and can be either black or plain. The other two have wooden elements and have four wood colour options.
}

\subsection{Requirements}

\subsection{Functional Requirements}
Looking at the outline above, there are basically two things the configurator needs to do; switch models (for frames) and switch colours (for both frames and chair itself). This should (logically) all be wrapped in a user interface where the user can switch the colours and models with their cursors. Some other things, inherit to product configurators are needed as well. To map these requirements in a way Peppr would do, these would amount to the following;

\begin{itemize}
	\item As an end-user, I want a friendly way to change the colour of the chair
	\item As an end-user, I want a friendly way to change the model of the frame
	\item As an end-user, I want to see my newly build configurator in enough ways to make a proper assertion as to wether or not I would buy this object
\end{itemize}

Dissecting these user-stories, some conclusions can be made as to what the front-end application of the system should do.
\begin{itemize}
	\item As a front-end, I need to be able to load 3d models into my scene
	\item As a front-end, I need a way to switch 3d models
	\item As a front-end, I need a way to have materials on the 3d models
	\item As a front-end, I need to show the 3d model realistic enough so the end-user can make a buy / do not buy choice
	\item As a front-end, I need to have a way for the user to navigate the scene and see the model from several points-of-view
	\item As a front-end, I need a way to know what colours the chair might have, so I can show the user his / her options
	\item As a front-end, I need a way to keep track of what models are in my scene, so I can apply the colour to the right object
	\item As a front-end, I need a way to keep track of the current configuration, so switching between different configurator options will keep the current configuration
\end{itemize}

From here, some user-stories for the back-end can be made.
\begin{itemize}
	\item As a back-end, I need to be able to supply 3d models to the front-end
	\item As a back-end, I need to show the front-end what options are available (both for models, as well as colours)
	\item As a back-end, I need to supply multiple 3d models if any configuration requires more than one model for a subset
\end{itemize}

While always difficult to estimate the exact requirements upfront, building a product configurator prototype using this short set of functional requirements should be sufficient to answer the research questions. 

\subsection{Technical Requirements}
Technical requirements are tricky in this case, as the prototype should be flexible and setting hard demands on for instance load times or uptimes, would interfere with the experiment. The most important thing is to see wether or not the functional requirements can be integrated and at what cost. The question for now is 'if' it is implementable, not when or how. As such, the technical requirements will be left unspecified.

\subsection{Technology Stack}
Now that the requirements are set, the technology stack can be chosen. Below are the three most important components for this stack. The 3d section (\ref{subsub: 3d}) is where is explained if and if so which framework is necessary for the front-end of the application to handle and render the 3d files in realtime. In the front-end section (\ref{subsub: frontEnd}) several front-end setups shall be discussed. An explanation of why there is no need for a back-end in this prototype will be given in the back-end section (\ref{subsub: backEnd})

\subsubsection{3d}
\label{subsub: 3d}
To display and render 3d models in browser, one can directly use the webGL api (\cite{webGL}). However, there are frameworks that make most of the work easier. There are loads of libraries that offer 3d capabilities in browsers, but the two most popular frameworks are ThreeJS (\cite{threejs}) and Babylon (\cite{babylon}). Having little to no experience with these libraries, the decision on which framework to use was made based on the amount of stars on Github. Babylon was starred 4479 times, ThreeJS 32.763 times, making ThreeJS the clear victor. Next to that, there are over 18.000 commits on the ThreeJS and only a bit more than 6.600 on the Babylon Framework.

\subsubsection{Front-end}
\label{subsub: frontEnd}
Apart from the 3d specific side of the front-end, things like styling buttons and setting HTML syntax should be handled as well. Both of these are easily chosen, basic HTML 5 will suffice for the lather, while an SCSS / SASS (\cite{scss}) is used for styling. SCSS has the advantage over CSS in that it has the ability to nest components, and use functions and variables. So in CSS, one would write something like this;

\begin{lstlisting}[language=CSS]
.button {
	background-color: #333;
	border-color: #333;
}
.button:hover {
	background-color: #000;
	border-color: #000;
}
.button.button-success {
	background-color: #00ff00;
	border-color: #00ff00;
}

.button.button-success:hover {
	background-color: #00dd00;
	border-color: #00dd00;
}
\end{lstlisting}

\clearpage
While in SCSS, one would do the following. While it takes up slightly more lines of code, the obvious advantages are readability, but also that one can specify colours and variables in one place and change the look of an entire application with just these variables.

\begin{lstlisting}[language=CSS]
$button-clr: #333;
$button-clr-success: #00ff00;
.button {
	background-color: $button-clr;
	border-color: $button-clr;
	&:hover {
		background-color: darken($button-clr, 10%);
		border-color: darken($button-clr, 10%);
	}
	
	&.button-success {
		background-color: $button-clr-success;
		border-color: $button-clr-success;
		&:hover {
			background-color: lighten($button-clr-success, 10%);
			border-color: lighten($button-clr-success, 10%);
		}
	}
}
\end{lstlisting}

So for displaying the control components, SCSS and HTML 5 will do. For the 3d, ThreeJS will be used. The only component in this stack that is not accounted for, is data and data flow. How does the ThreeJS component know that an HTML 5 button was just pressed? There are loads of ways to handle data flow within an application, MVC, MVP, MVVM (\cite{MVCMVPMVVM}) and loads of Javascript front-end frameworks to choose from (\cite{javascriptAnno2016}). While the lather article explains the state of front-end development quite humorously, there is some truth to this. This means choosing a framework to use is tricky. In case of this prototype Peppr thought it would be best to use that which they are familiar with and have used in a variety of projects; Angular. At the time of writing Angular 2 has just been released out of beta, but support for it with the relatively quick upcoming version of Angular 4 (they skipped version 3) do not make it suitable for building this prototype.
There is a bit of a learning curve to Angular and performance is one of the biggest short-comings. The performance troubles Angular deals with are mostly due to the data binding and DOM watching though. This is something the prototype will not be bottlenecking on. There will be little to no watchers as the frame buffer for the 3d output will be rendered to a Canvas element, in which there are no Angular watchers.

\subsubsection{Back-end}
\label{subsub: backEnd}

%----------------------------------------------------------------------------------------
%   The Prototype
%----------------------------------------------------------------------------------------
\section{The prototype}
\subsection{Introduction}

%----------------------------------------------------------------------------------------
%   Development
%----------------------------------------------------------------------------------------
\section{Development}

%----------------------------------------------------------------------------------------
%   Is it possible to eliminate all issues (time and automation) with regards to rendering?
%----------------------------------------------------------------------------------------
\subsection{Is it possible to eliminate all issues (time and automation) with regards to rendering?}

%----------------------------------------------------------------------------------------
%   What is the cost differences for development?
%----------------------------------------------------------------------------------------
\subsection{What is the cost differences for development?}
% Estimate time for both projects
% Find 3d pricing
% Find developer pricing for CMS
% Find developer pricing for custom
% Check server costs
% Check CMS average upgrade cyclus
% Check NPM package average upgrade cyclus
% Check main NPM package upgrade cyclus
% Initial, Server costs, Upgrade costs

%----------------------------------------------------------------------------------------
%   What are the differences in Workflows
%----------------------------------------------------------------------------------------
\subsection{What are the differences in Workflows?}

%----------------------------------------------------------------------------------------
%   How flexible is the end result compared to previous generation configurators
%----------------------------------------------------------------------------------------
\subsection{How flexible is the end result compared to previous generation configurators}
% Estimate time in old way
% Find 3 different product configurators
% See how far we get re-building them using the CMS
% Estimate time in new way

%----------------------------------------------------------------------------------------
%   How easy is it so maintain the application compared to existing configurators?
%----------------------------------------------------------------------------------------
\subsection{How easy is it so maintain the application compared to existing configurators?}
% Interview Frederick with regards to maintaining the application / costs (what is it like owning a setup like that)
% --> from "What is the cost difference for development?"
% Use CMS average upgrade cyclus
% Use NPM package average upgrade cyclus
% Use main NPM package upgrade cyclus

%----------------------------------------------------------------------------------------
%   How easy is it to add new options to the configurator compared to the existing configurators?
%----------------------------------------------------------------------------------------
\subsection{How easy is it to add new options to the configurator compared to the existing configurators?}
% Estimate time in old way
% Add new options to configurator
% Estimate time in new way

%----------------------------------------------------------------------------------------
%   User Experience
%----------------------------------------------------------------------------------------
\section{User Experience}
Apart from the development cycle, the user experience is a huge part of whether using these types of configurators is viable or not. Even if the development is way cheaper, if users cannot use the application, problems will arise and the old method may prove to be a better option.

%----------------------------------------------------------------------------------------
%   Is the technology compatible with the users browsing preferences?
%----------------------------------------------------------------------------------------
\subsection{Is the technology compatible with the users browsing preferences?}
% Scan 'caniuse.com' for theoretical problems
% Setup domain with browserify and see how it renders

%----------------------------------------------------------------------------------------
%   Is the new technology small enough?
%----------------------------------------------------------------------------------------
\subsection{Is the new technology small enough?}
% Record network activity for three other product configurators that have a comparable setup
% Record network activity for OpenGL version
% Find average site size
% Find psychology behind it

%----------------------------------------------------------------------------------------
%   Is the new technology small enough?
%----------------------------------------------------------------------------------------
\subsection{Is the new technology quick enough?}
% Old -- Record / time switching between 'models'
% Old -- Record / time switching between 'materials'
% New -- Record / time switching between 'models'
% New -- Record / time switching between 'materials'
% Use data from bandwidth to calculate average loading time per network type (2g, 3g, 4g, etc.)
%----------------------------------------------------------------------------------------
%   Introduction
%----------------------------------------------------------------------------------------
\chapter{Introduction}

Peppr is a company specialising in building photo-realistic visualisations. In 2014, Peppr built a product configurator for SlimFitted, a company that makes tailored shirts. They wanted a platform on which their customers would be able to order customised shirts.

The customer requested 25 colors, 2 perspectives, 7 types of collars, 6 types of sleeves and 3 different plaids. This would amount to 6300 possible shirt combinations. Creating all the combinations is massive undertaking. A reason why most web-based product configurators are splitting the final images into several layers. But even with a smart division, Peppr still needed to render a staggering amount of images.

Apart from the images, Peppr encountered a problem with regards to software. For every configurator, the user needs to be able to view and edit a configuration in a simple way. Unfortunately, this means something different for all configurators. Combined with branding, creating a universal and re-usable configurator is difficult.

In their research, Peppr stumbled upon a technology called OpenGL. The first version released March 2011 (\cite{OpenGL Website}). WebGL technology renders from the video processor and opens up the web to a whole new way of using 3d models. Using 3d models instead of images could make configurators easier to build and maintain. Unfortunately, the adoption rate of WebGL has always been low. Only the latest browser versions would have the technology. Next to that, there are hardware limitations on mobile phones. Anno 2016 though, the playing field has changed. With more browsers supporting the technology, timing might be perfect to start using it.

Peppr has done these projects and states that the usual way of business consist of two parts. One being the images, the other, the software. In the outline below follows a brief description of how the process is currently done. 

For this thesis, we will use the following example. Please note that this process is the way Peppr handles projects like this. This is not necessarily the best way to handle a project like this one.
\newline
\say{
A chair manufacturer wants a product configurator for one of their most popular chairs. It consists 25 different colours and has 4 different subframes. Two of the subframes are steel and can be either black or plain. The other two have wooden elements and have four wood colour options.
}

%----------------------------------------------------------------------------------------
%   Visuals
%----------------------------------------------------------------------------------------
\section{Visuals}

%----------------------------------------------------------------------------------------
%   Image Planning
%----------------------------------------------------------------------------------------
\subsection{Image Planning}
Product configurators may have to deal with an exponentially growing set of options. Peppr always checks if these image sets can be split into separate components. This may make the set smaller and easier to maintain. Below is a summary of the option set, split per item so we can start calculating how many images will be necessary.
\begin{itemize}
	\item 25 colours - \textbf{(\( \alpha \))}
	\item 2 steel frames - \textbf{(\( \beta \))}
	\item 2 frame colours - \textbf{(\( \gamma \))}
	\item 2 wood frames - \textbf{(\( \delta \))}
	\item 4 wood colours - \textbf{(\( \epsilon \))}
\end{itemize}

In this case, any seat has a pick of several frame options, and several colours. But steel frames have two colours and wood frames have four colours. To calculate the full amount of options ($x$), we can use the following formula:
 
\[ f(x) = (\alpha \cdot \beta \cdot \gamma) + (\alpha \cdot \delta \cdot \epsilon)\]
\[ f(x) = (25 \cdot 2 \cdot 2) + (25 \cdot 2 \cdot 4)\]
\[ f(x) = 300\]

Going with just 1 colour more adds 12 extra renders. While this does not seem like much, these renders are build from several different files. This means an artist has to open 12 different files, and do the edit 12 times.
In some cases, you might be able to get around it using layers. In this case, splitting up the chair into a seat and frame layer will get us the following formula:

\[ f(x) = (\alpha) + (\cdot \beta \cdot \gamma) + (\cdot \delta \cdot \epsilon)\]
\[ f(x) = (25) + (2 \cdot 2) + (2 \cdot 4)\]
\[ f(x) = 37\]

This decreases the amount of renders. Unfortunately, while this works here, in some cases this is not possible. Sometimes, one of the objects is both in front and behind other objects. This makes it difficult to 'mask'. Also, creating new layers does add complexity and constraints. Adding new options and layers might prove difficult when they overlap with existing layers.
\newline
Apart to difficulties in the 3d process, these layers need to be build into the software as well. Either by creating an API that serves the layers as one image (\cite{Bugaboo} ), or by stacking the images client-side. The user will notice this option though, as it slows things down. This is fixed with the adoption of HTTP 2.0. This pipelines the http-requests, reducing latency (\cite{latency}).

%----------------------------------------------------------------------------------------
%   Modeling
%----------------------------------------------------------------------------------------
\subsection{Modeling}
Step two is the modelling proces where an artist makes a virtual model. Either from scratch, or by 3d scanning real-life objects. If the choice to go for layers in the renders has been made, the modeller make sure he keeps this in mind.

%----------------------------------------------------------------------------------------
%   Lighting / Shading
%----------------------------------------------------------------------------------------
\subsection{Lighting \& Shading}
Once in the lighting department, the model is placed into a suitable environment. Most of the time a studio setup. There it is lit and shaded (the process of creating a life-like material) to perfection. The artist makes sure that when there are layers involved, the shadows do not overlap the layers.
%----------------------------------------------------------------------------------------
%   Rendering
%----------------------------------------------------------------------------------------
\subsection{Render}
This is where things get together and the calculation from 3d model to actual image start. The actual rendering proces differs. Sometimes it is easier to render out the whole sequence with every configuration. Other times, it is easier to render just one point-of-view at a time.


%----------------------------------------------------------------------------------------
%   Post Production
%----------------------------------------------------------------------------------------
\subsection{Post Production}
Every 3d model needs a bit of post production to make it look better. If the model has layers rendered as masks (an option to overcome overlapping images). This is the step where they would split them into the different layers.
%----------------------------------------------------------------------------------------
%   Compression
%----------------------------------------------------------------------------------------
\subsection{Compression}
Using images on the web, especially on bigger resolution displays, small images are important. Current mobile data speeds and capped contracts are difficult. So laying a 50mb burden upon the user when opening a site is not a good idea. This is were compression comes in. Every images gets compressed for a fast download, while remaining a good quality.
%----------------------------------------------------------------------------------------
%   Software
%----------------------------------------------------------------------------------------
\section{Software}

%----------------------------------------------------------------------------------------
%   Requirements
%----------------------------------------------------------------------------------------
\subsection{Requirements}
Peppr starts out a software project by working out both functional and technical requirements.

â€‹
%----------------------------------------------------------------------------------------
%   Functional Requirements
%----------------------------------------------------------------------------------------
\subsubsection{Functional Requirements}
Functional requirements help map out required functionality of an application. In an agile (\cite{Agile: User Stories}) working environment, these are 'user stories'. Peppr prefers the term requirements. They do generally use the same notation. \newline

\say{\textit{As a <type of user>, I want <some goal>, so that <some reason>}}\newline

In the context of the configurator specified above, a requirement could be: \newline

\say{\textit{As a \textbf{User}, I want \textbf{to be able to save my configuration}, so that \textbf{I can later continue were I left off with my configuration}}}\newline

%----------------------------------------------------------------------------------------
%   Technical Requirements
%----------------------------------------------------------------------------------------
\subsubsection{Technical Requirements}
Contrary to popular belief, these requirements are not the implementation details of the functional requirements. They are the requirements the system itself. The technical requirements handle things like performance, availability and security. Some put these in a list \cite{Agile: Technical Requirements}, but Peppr uses the same format as the user stories. \newline

\say{\textit{As a <type of \textbf{system}>, I want <some goal>, so that <some reason>}}\newline

Peppr uses this to differentiate between different types of systems. An example of a technical requirement can be found below. This specific one has to do with limiting an API's response time (\cite{Response Times}).

\say{\textit{As an \textbf{API}, I want \textbf{to respond within 300ms}, so that \textbf{the user feels in control of the application at all times}}}\newline

%----------------------------------------------------------------------------------------
%   CMS
%----------------------------------------------------------------------------------------
\subsection{CMS}
A content management system has basic functionality built in (like user management, file handling). It does however, require  the developer to work in the way the system intended. The other option is to go with a system that is written from the ground up. It will be much leaner and quicker when deployed, but will not be as mature as a popular CMS. So if the system is not built right, it may result in a buggy experience for the end user. In Peppr's case, a CMS called Magento was used during implementation. One thing to keep in mind; In case of a custom application, a back-end needs to be developed as well.
%----------------------------------------------------------------------------------------
%   UX Development
%----------------------------------------------------------------------------------------
\subsection{UX Development}
While this term gets thrown around a lot, the UX (User Experience) covers not only the UI of the application. It is a broader term to describe how users undergo the experience of customising a product. Itis how they learn to use the product configurator. How the application can help the user in the best possible way to do so. Don Normal (\cite{User Experience}) says: \newline
\say{\textit{The first requirement for an exemplary user experience is to meet the exact needs of the customer, without fuss or bother. Next comes simplicity and elegance that produce products that are a joy to own, a joy to use. True user experience goes far beyond giving customers what they say they want, or providing checklist features.}} \newline
In other words, UX is not only helping the user to meet his or her goal. It is to go beyond that, and make the experience joyful.

%----------------------------------------------------------------------------------------
%   Back-End Development
%----------------------------------------------------------------------------------------
\subsection{Back-End Development}
Techopedia (\cite{Back-End Developer Definition}) states that a back-end developer's task is to develop and maintain a logical or computational back-end for a website. Focussing on C++, C\#, Java, or another high-level programming language.Another Definition (\cite{Back-End Developer Definition 02}) states back-ends are mostly developed using either Ruby or Python.
In reality, any programming languages that can interact with a databases can act as a back-end. For instance, the 'Dollar Shave Club' uses 6 languages in their infrastructure (\cite{Dollar Shave Club back-end}). 'Uber', uses a completely different stack (\cite{Uber back-end}).
Peppr generally uses a microservices architecture for their apps (\cite{Microservices}). This pattern allows the use of different applications. So, Peppr can build each application using a specific language and with a specific target in mind. So imagine a configurator needs to stack images but also needs a realtime chatbot. Peppr will be able to handle the high concurrency using something like Elixr. The realtime chatbot will then made with Firebase, a realtime service (\cite{Firebase}).

%----------------------------------------------------------------------------------------
%   Front-End Development
%----------------------------------------------------------------------------------------
\subsection{Front-End Development}
According to Wikipedia, a Front-End Developer (\cite{Front-End Developer Definition}) produces the client-side interface. Wikipedia states that they use HTML, CSS and Javascript. However, anno 2016, Front-End Development has become quite a bit broader (\cite{Javascript Anno 2016}). For relatively complex projects like configurators, building a front-end can be a daunting task. More often than not, you will want to serve the changes to the user instantly, without a page refresh. Resulting in an asynchronous application.
Building an asynchronous application can be done in many ways. The most convenient way is to build a Single-Page-Application (SPA). This gives the user a desktop-like experience (\cite{Single Page Applications}). As stated on Wikipedia, there are some caveats to this, like search engine optimisation, speed and browser history. Fortunately (and unfortunately), there are frameworks to help build an SPA. Anno 2016, the field of Front-End Development is clouded with frameworks to help build these types of applications. MeteorJS, React, Angular, Vue and many more (\cite{Front-End Javascript Frameworks} ).
Peppr develops most of their applications using Angular. They found that the code is easiest to maintain and the separation of concerns using a MVC type setup works well with Angular.

\newpage











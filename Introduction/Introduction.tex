\newpage
%----------------------------------------------------------------------------------------
%   Introduction
%----------------------------------------------------------------------------------------
\chapter{Introduction}

Peppr is a company specialising in building photo-realistic visualisations. Late 2014, Peppr built a product configurator for SlimFitted, a company that makes tailored shirts. They wanted a platform on which their customers would be able to order customized shirts.

The customer requested 25 colors, 2 perspectives, 7 types of collars, 6 types of sleeves and 3 different plaids. This would amount to 6300 possible shirt combinations. Creating all the combinations is massive undertaking, which it why most web-based product configurators are built by splitting the final image into several configurable components. But even with the smart division of layers, Peppr still needed to render a staggering amount of images.

Apart from the images, Peppr encountered a problem that needed to be solved with regards to software. For every configurator, the end-user needs to be able to view and edit a configuration in a user-friendly way. Unfortunately, this means something different for all configurators. Combined with branding, creating a universal and more importantly, re-usable configurator is extremely difficult.

After some research, Peppr stumbled upon a technology called OpenGL which was released in March 2011 (\cite{OpenGL Website}), an implementation of OpenGL technology for the web. WebGL technology renders directly from the video processor and it opens up the web to a whole new way of using actual 3d models. Being able to use the 3d models instead of the vast amount of images would make the configurators easier (less expensive) to build and maintain. Unfortunately, the actual adoption rate of WebGL has always been low because only the latest browsers would integrate the technology and there were hardware limitations on mobile phones. Anno though, the playing field has changed. With more-and-more browsers supporting this new type of technology, the timing might be perfect to bring it to the masses.

Peppr has done these projects in the past and states that the usual way of producing configurators consists of two sub-projects; the images, and the software. In the outline below follows a brief description of how the process is currently done at Peppr and some advantages that can be made when using OpenGL.
For this introduction, the following example project shall be used. Please note that the following process is the way Peppr would handle a project like this.
\newline
\say{
A chair manufacturer wants a product configurator for one of their most popular chairs. It can be delivered in 25 different colours and has 4 different subframes. Two of the subframes are fully made from steel and can be delivered in either black or plain steel, the other two have wooden elements and have four different wood colour options.
}

%----------------------------------------------------------------------------------------
%   Visuals
%----------------------------------------------------------------------------------------
\section{Visuals}

%----------------------------------------------------------------------------------------
%   Image Planning
%----------------------------------------------------------------------------------------
\subsection{Image Planning}
Product configurators possibly have to deal with an exponentially growing set of options. Peppr believes it is good practice to see if these images can be split into separate components that make the image set smaller and easier to maintain. Below is a summary of the full option set, split per item so we can start calculating how many images will be necessary.
\begin{itemize}
	\item 25 colours - \textbf{(\( \alpha \))}
	\item 2 steel frames - \textbf{(\( \beta \))}
	\item 2 frame colours - \textbf{(\( \gamma \))}
	\item 2 wood frames - \textbf{(\( \delta \))}
	\item 4 wood colours - \textbf{(\( \epsilon \))}
\end{itemize}

In this case, any seat has a pick of several frame options, and several colours. But steel frames have two colours and wood frames have four colours. To calculate the full amount of options ($x$), we can use the following formula:
 
\[ f(x) = (\alpha \cdot \beta \cdot \gamma) + (\alpha \cdot \delta \cdot \epsilon)\]
\[ f(x) = (25 \cdot 2 \cdot 2) + (25 \cdot 2 \cdot 4)\]
\[ f(x) = 300\]

Going with just 1 colour more adds 12 extra renders. While this may not seem like much, more often than not, these renders need to be build from several different files. This means an artist has to open 12 different files, and do the edit 12 times.
Fortunately, in some cases, you might be able to get around it using layers. In this case, splitting up the chair into a seat and frame layer will get us the following formula:

\[ f(x) = (\alpha) + (\cdot \beta \cdot \gamma) + (\cdot \delta \cdot \epsilon)\]
\[ f(x) = (25) + (2 \cdot 2) + (2 \cdot 4)\]
\[ f(x) = 37\]

This decreases the amount of renders massively. Unfortunately, while this may work in this case, in some cases this is not possible because the object is being obstructed in its view, making it extremely difficult to 'mask'. Next to that, creating new layers does add complexity and constraints. Adding new options / layers later on might prove extremely difficult if they were to overlap with existing layers.
\newline
Apart to difficulties in the 3d process, these layers need to be build into the software as well. Either by creating an API that serves those layers as one image (Like the Bugaboo configurator \cite{Bugaboo} ) or a front-end that can layer multiple images in a correct way. In the lather case, the user will directly notice this option as it slows things down, this should be resolved with the adoption of HTTP 2.0 and the pipelining of http-requests (\cite{latency}), although some overhead will exist.

%----------------------------------------------------------------------------------------
%   Modeling
%----------------------------------------------------------------------------------------
\subsection{Modeling}
Step two in the chain is the modelling proces whereby a virtual model is being created, either from scratch, or by 3d scanning real-life objects. If the choice to go for layers in the renders have been made, the modeller make sure he keeps this in mind.

%----------------------------------------------------------------------------------------
%   Lighting / Shading
%----------------------------------------------------------------------------------------
\subsection{Lighting \& Shading}
In the lighting department, the model is being put into a suitable environment (mostly studio like setups), where it is lit and shaded (process of creating a life-like material) to perfection. The lighter must make sure that when there are layers involved, there is no unwanted shadow casting because when hiding certain layers for rendering.

%----------------------------------------------------------------------------------------
%   Rendering
%----------------------------------------------------------------------------------------
\subsection{Render}
This is where things get together and the calculation from 3d model to actual image start. Depending on the configuration and setup, one renders the entire sequence, if < 100 renders and only one point of view for instance, one might swap out the model at certain frames. If one needs to render 360's, rendering one file at at time is better suitable.

%----------------------------------------------------------------------------------------
%   Post Production
%----------------------------------------------------------------------------------------
\subsection{Post Production}
Every 3d model needs a bit of post production to make it look better. Also, if the model was split out into different layers but these were rendered as masks (an option to overcome overlapping images), this is where they would be split out into the different layers.

%----------------------------------------------------------------------------------------
%   Compression
%----------------------------------------------------------------------------------------
\subsection{Compression}
Using images of the web, especially on @2x or @3x resolution devices, mostly phones and tablets which get their data through mobile networks, compression is extremely important. With current mobile data speeds and capped contracts, laying a 50mb burden upon the user when opening a site is not a good idea.

%----------------------------------------------------------------------------------------
%   Software
%----------------------------------------------------------------------------------------
\section{Software}

%----------------------------------------------------------------------------------------
%   Requirements
%----------------------------------------------------------------------------------------
\subsection{Requirements}
Peppr generally starts out a software project by working out both functional and technical requirements.

%----------------------------------------------------------------------------------------
%   Functional Requirements
%----------------------------------------------------------------------------------------
\subsubsection{Functional Requirements}
Functional requirements are used to map out the required functionality of the application. In an agile \cite{Agile: User Stories} working environment, these would be referred to as 'user stories', but Peppr prefers the term requirements. They do generally use the same notation.\newline

\say{\textit{As a <type of user>, I want <some goal>, so that <some reason>}}\newline

In the context of the configurator specified above, a requirement could be: \newline

\say{\textit{As a \textbf{User}, I want \textbf{to be able to save my configuration}, so that \textbf{I can later continue were I left off with my configuration}}}\newline

%----------------------------------------------------------------------------------------
%   Technical Requirements
%----------------------------------------------------------------------------------------
\subsubsection{Technical Requirements}
Contrary to popular belief, technical requirements are not the technical implementation details of the functional requirements, but they are the requirements the system itself needs to fulfil with regards to things like performance, availability and security. Some simply put these in a list \cite{Agile: Technical Requirements}, but Peppr handles the same format as the user stories.\newline

\say{\textit{As a <type of \textbf{system}>, I want <some goal>, so that <some reason>}}\newline

This way, Peppr is able to differentiate between different systems like an API or a Front-End web application. Below follows an example of a technical requirement where we want to limit the API's response time (\cite{Response Times})\newline

\say{\textit{As an \textbf{API}, I want \textbf{to respond within 300ms}, so that \textbf{the user feels in control of the application at all times}}}\newline

%----------------------------------------------------------------------------------------
%   CMS
%----------------------------------------------------------------------------------------
\subsection{CMS}
A content management system has basic functionality built in (user management, file handling, basic front-end), but it does require to work in the way that system is meant to be worked in. The other option, going with a from the ground up written system, will be much leaner and quicker when deployed, but will not be as mature as a popular CMS, which, if the system is not built properly, might result in a buggy experience for the end user. In Peppr's case, a CMS called Magento was used for the implementation. In case of a fully custom application, a back-end needs to be developed as well.

%----------------------------------------------------------------------------------------
%   UX Development
%----------------------------------------------------------------------------------------
\subsection{UX Development}
While this term gets thrown around a lot, the UX (User Experience) covers not only the UI of the application, but is a broader term to describe how users undergo the experience of customising a product. How they learn to use the product configurator, and how the application can help the user in the best possible way to do so. Don Normal (\cite{User Experience}) says: \newline
\say{\textit{The first requirement for an exemplary user experience is to meet the exact needs of the customer, without fuss or bother. Next comes simplicity and elegance that produce products that are a joy to own, a joy to use. True user experience goes far beyond giving customers what they say they want, or providing checklist features.}} \newline
In other words, UX is not only helping the user to meet his or her goal, but to go beyond that, and make the experience joyful.

%----------------------------------------------------------------------------------------
%   Back-End Development
%----------------------------------------------------------------------------------------
\subsection{Back-End Development}
According to Techopedia (\cite{Back-End Developer Definition}), a back-end developer's primary task is to develop and maintain a logical or computational back-end for a website. Typically focussing in on C++, C\#, Java, or another high-level programming language.
Another Definition (\cite{Back-End Developer Definition 02}) states back-ends are mostly developed using either Ruby or Python.
In reality however, any programming languages that can interact with a databases and serve that data can act as a back-end. For instance, the 'Dollar Shave Club' uses 6 different languages across their back-end infrastructure (\cite{Dollar Shave Club back-end}), while Uber uses a completely different stack (\cite{Uber back-end}).
Peppr generally uses a microservices architecture for their apps (\cite{Microservices}). This pattern allows the use of multiple applications, so Peppr can build each application using a specific language and with a specific target in mind. For example, Peppr can opt to handle real-time data (like a real-time help chat in a configurator) using a service called Firebase (\cite{Firebase}), which easily implements directly into front-ends, while handling other tasks that need high concurrency and scalability (like stacking the layers in a back-end to a complete image and delivering them to the front-end) with an Elixer application (\cite{Elixr})

%----------------------------------------------------------------------------------------
%   Front-End Development
%----------------------------------------------------------------------------------------
\subsection{Front-End Development}
According to Wikipedia, a Front-End Developer (\cite{Front-End Developer Definition}) produces the client-side interface using HTML, CSS and Javascript. However, anno 2016, Front-End Development has become quite a bit broader (\cite{Javascript Anno 2016}). For relatively complex projects like configurators, building a front-end can be a daunting task. More often than not, you will want to serve the changes to the user instantly, without a page refresh. Resulting in an asynchronous application.
Building an asynchronous application can be done in numerous ways. By far the most convenient way is by building Single-Page-Application (SPA), this might give the user a desktop-like experience (\cite{Single Page Applications}). As stated on Wikipedia, there are some caveats to this, like search engine optimisation, speed and browser history. Fortunately (and unfortunately), there are frameworks to help build a SPA. Anno 2016, the field of Front-End Development is clouded with frameworks to help build these types of applications. MeteorJS, React, Angular, Vue and many more ().
Peppr develops most of their applications using Angular. They found that the code is easiest to maintain and the separation of concerns using a MVC type setup works well with Angular.

\newpage










